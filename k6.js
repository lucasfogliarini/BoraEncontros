/*
| Tempo de Resposta | Classifica√ß√£o     | Coment√°rio                                         |
| ----------------- | ----------------- | -------------------------------------------------- |
| < 1ms             | Ultra-r√°pido      | Resposta instant√¢nea, geralmente cache in-memory   |
| 1‚Äì5ms             | Excelente         | Datacenter local, processamento m√≠nimo             |
| 5‚Äì20ms            | Muito bom         | API r√°pida, lat√™ncia m√≠nima em rede local          |
| 20‚Äì100ms          | Bom               | Normal para APIs bem otimizadas                    |
| 100‚Äì500ms         | Aceit√°vel         | Us√°vel, mas pode afetar responsividade em massa    |
| 500ms ‚Äì 1s        | Lento             | Percept√≠vel, cuidado em chamadas em sequ√™ncia      |
| > 1s              | Cr√≠tico / Ruim    | Prejudica experi√™ncia, rever otimiza√ß√µes urgentes  |
*/


import http from 'k6/http';
import { check, sleep } from 'k6';

const endpoint = 'https://api.bora.host/calendars/lucasfoglairini/events';
const token;

const request = {
  method: 'GET', // POST, GET, PUT, DELETE
  url: endpoint,
  headers: {
    Authorization: `Bearer ${token}`,
    'Content-Type': 'application/json',
    'Accept': 'text/plain',
    'User-Agent': 'k6',
  },
    body: JSON.stringify({

    }),
};

const executor = 'constant-arrival-rate'; // Executor que mant√©m uma taxa constante de requisi√ß√µes
//const executor = 'constant-vus'; // Executor que mant√©m um n√∫mero constante de VUs (Virtual Users)
const rate = 200; // Taxa de requisi√ß√µes por minuto
const durationValue = 1; // Dura√ß√£o do teste em durationUnit
const durationUnit = 'm'; // 'm' para minutos, 's' para segundos
const vus = 150; // N√∫mero de VUs alocados ou pr√©-alocados para o teste

const timeoutValue = 5;
const timeout = `${timeoutValue}s`; // Define o timeout para as requisi√ß√µes
const duration = durationValue + durationUnit; // Converte o valor de dura√ß√£o para o formato correto

export const options = {
  scenarios: {
    run: {
      executor: executor,
      //vus: vus, // N√∫mero de VUs alocados para o teste usando executor 'constant-vus'
      preAllocatedVUs: vus, // N√∫mero de VUs pr√©-alocados para o teste
      maxVUs: vus * 10, // N√∫mero m√°ximo de VUs que podem ser alocados durante o teste
      rate: rate, // Taxa de requisi√ß√µes por minuto usando executor 'constant-arrival-rate'
      timeUnit: '1m',// Define a taxa de requisi√ß√µes por minuto
      duration: duration, // Dura√ß√£o do teste
      exec: 'run', // Nome da fun√ß√£o que ser√° executada
    }
  },
};

export function run() {
  const res = http.request(request.method, request.url, request.body, { headers: request.headers, timeout: timeout });
  console.log(`${res.status_text}: ${res.timings.duration}ms`);
  check(res, {
      '200_399': (r) => r.status >= 200 && r.status < 400
  });

  //sleep(1); // Pausa de 1 segundo entre as requisi√ß√µes
}

export function handleSummary(data) {
  // Helper para converter bytes para MB
  const bytesToMB = (bytes) => (bytes / (1024 * 1024)).toFixed(2);

  const {
    iterations,
    successRate,
    successPasses,
    failureRate,
    successFails
} = getStatusRates(data);

  const testRunDurationSec = (data.state.testRunDurationMs / 1000);
  const testRunDurationMin = (testRunDurationSec / 60);
  const rateSec = data.metrics.http_reqs.values.rate;
  const rateMin = rateSec * 60;
  const vusAvgAprox = (data.metrics.vus.values.min + data.metrics.vus.values.max) / 2;
  return {
    stdout: `
======== üìä Resumo do teste usando ${executor} ========

üåê Endpoint: ${request.method} ${request.url}

üìä Requisi√ß√µes por status
  - üü¢ Sucesso (2xx-3xx): ${successRate.toFixed(2)}% (${successPasses} de ${iterations})
  - üî¥ Falhas (4xx-5xx): ${failureRate.toFixed(2)}% (${successFails} de ${iterations})

‚ö° Taxa de Entrada | Arrival Rate (Œª): 
    - ${rateMin.toFixed()} req/min ou ${rateSec.toFixed(2)} req/s (executado)
    - ${rate} req/min (configurado)

‚úÖ Vaz√£o | Throughput (X): 
    ${(successPasses / testRunDurationMin).toFixed(2)} req/min ou ${(successPasses / testRunDurationSec).toFixed(2)} req/s

‚è± Tempo de resposta | Response Time (R):
   - M√©dia: ${data.metrics.http_req_duration.values.avg.toFixed(2)} ms
   - M√°ximo: ${data.metrics.http_req_duration.values.max.toFixed(2)} ms
   - M√≠nimo: ${data.metrics.http_req_duration.values.min.toFixed(2)} ms
   - Mediana: ${data.metrics.http_req_duration.values.med.toFixed(2)} ms


üë• Usu√°rios Virtuais por segundo | Virtual Users (Œª‚ãÖR):
   - M√©dio: ${vusAvgAprox}
   - M√°ximo: ${data.metrics.vus.values.max}
   - M√≠nimo: ${data.metrics.vus.values.min}

üîÅ Itera√ß√µes conclu√≠das: ${data.metrics.iterations.values.count}

üì§ Tr√°fego de dados:
   - Enviados:  ${bytesToMB(data.metrics.data_sent.values.count)} MB
   - Recebidos: ${bytesToMB(data.metrics.data_received.values.count)} MB

‚è±Ô∏è Dura√ß√£o total do teste: ${testRunDurationSec.toFixed(2)} s
`,
  };
}

function getStatusRates(data) {
  const checkStatusSuccess = data.root_group.checks.find(c => c.name === '200_399');

  const iterations = data.metrics.iterations.values.count;

  const successPasses = checkStatusSuccess?.passes || 0;
  const successFails = checkStatusSuccess?.fails || 0;

  const successRate = iterations > 0 ? (successPasses / iterations) * 100 : 0;
  const failureRate = iterations > 0 ? (successFails / iterations) * 100 : 0;

  return {
    iterations,
    successRate,
    successPasses,
    failureRate,
    successFails
  };
}
